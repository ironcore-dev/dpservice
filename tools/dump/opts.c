// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company and IronCore contributors
// SPDX-License-Identifier: Apache-2.0

/***********************************************************************/
/*                        DO NOT EDIT THIS FILE                        */
/*                                                                     */
/* This file has been generated by dp_conf_generate.py                 */
/* Please edit dp_conf.json and re-run the script to update this file. */
/***********************************************************************/

#include "dp_argparse.h"

#ifndef ARRAY_SIZE
#	define ARRAY_SIZE(ARRAY) (sizeof(ARRAY) / sizeof((ARRAY)[0]))
#endif

enum {
	OPT_HELP = 'h',
	OPT_VERSION = 'v',
_OPT_SHOPT_MAX = 255,
	OPT_DROPS,
	OPT_NODES,
	OPT_FILTER,
	OPT_PCAP,
	OPT_STOP,
};

#define OPTSTRING ":hv" \

static const struct option dp_conf_longopts[] = {
	{ "help", 0, 0, OPT_HELP },
	{ "version", 0, 0, OPT_VERSION },
	{ "drops", 0, 0, OPT_DROPS },
	{ "nodes", 1, 0, OPT_NODES },
	{ "filter", 1, 0, OPT_FILTER },
	{ "pcap", 1, 0, OPT_PCAP },
	{ "stop", 0, 0, OPT_STOP },
	{ NULL, 0, 0, 0 }
};

static bool showing_drops = false;
static bool stop_mode = false;

bool dp_conf_is_showing_drops(void)
{
	return showing_drops;
}

bool dp_conf_is_stop_mode(void)
{
	return stop_mode;
}



/* These functions need to be implemented by the user of this generated code */
static void dp_argparse_version(void);
static int dp_argparse_opt_nodes(const char *arg);
static int dp_argparse_opt_filter(const char *arg);
static int dp_argparse_opt_pcap(const char *arg);


static inline void dp_argparse_help(const char *progname, FILE *outfile)
{
	fprintf(outfile, "Usage: %s [options]\n"
		" -h, --help           display this help and exit\n"
		" -v, --version        display version and exit\n"
		"     --drops          show dropped packets\n"
		"     --nodes=REGEX    show graph node traversal, limit to REGEX-matched nodes (empty string for all)\n"
		"     --filter=FILTER  show only packets matching a pcap-style FILTER\n"
		"     --pcap=FILE      write packets into a PCAP file\n"
		"     --stop           do nothing, only make sure tracing is disabled in dp-service\n"
	, progname);
}

static int dp_conf_parse_arg(int opt, const char *arg)
{
	(void)arg;  // if no option uses an argument, this would be unused
	switch (opt) {
	case OPT_DROPS:
		return dp_argparse_store_true(&showing_drops);
	case OPT_NODES:
		return dp_argparse_opt_nodes(arg);
	case OPT_FILTER:
		return dp_argparse_opt_filter(arg);
	case OPT_PCAP:
		return dp_argparse_opt_pcap(arg);
	case OPT_STOP:
		return dp_argparse_store_true(&stop_mode);
	default:
		fprintf(stderr, "Unimplemented option %d\n", opt);
		return DP_ERROR;
	}
}

enum dp_conf_runmode dp_conf_parse_args(int argc, char **argv, int *positional_index)
{
	const char *progname = argv[0];
	int option_index = -1;
	int opt;

	while ((opt = getopt_long(argc, argv, OPTSTRING, dp_conf_longopts, &option_index)) != -1) {
		switch (opt) {
		case OPT_HELP:
			dp_argparse_help(progname, stdout);
			return DP_CONF_RUNMODE_EXIT;
		case OPT_VERSION:
			dp_argparse_version();
			return DP_CONF_RUNMODE_EXIT;
		case ':':
			fprintf(stderr, "Missing argument for '%s'\n", argv[optind-1]);
			return DP_CONF_RUNMODE_ERROR;
		case '?':
			if (optopt > 0)
				fprintf(stderr, "Unknown option '-%c'\n", optopt);
			else
				fprintf(stderr, "Unknown option '%s'\n", argv[optind-1]);
			return DP_CONF_RUNMODE_ERROR;
		default:
			if (DP_FAILED(dp_conf_parse_arg(opt, optarg))) {
				if (option_index >= 0)
					fprintf(stderr, "Invalid argument for '--%s'\n", dp_conf_longopts[option_index].name);
				else
					fprintf(stderr, "Invalid argument for '-%c'\n", opt);
				return DP_CONF_RUNMODE_ERROR;
			}
		}
		option_index = -1;
	}

	if (positional_index)
		*positional_index = optind;

	return DP_CONF_RUNMODE_NORMAL;
}

