syntax = "proto3";

package dpdkonmetal;
option go_package = "./dpdkproto";

//// ENUMS
enum InterfaceType {
	VIRTUAL = 0;
	BAREMETAL = 1;
}

enum IPVersion {
	IPV4 = 0;
	IPV6 = 1;
}

enum Protocol {
	UNDEFINED = 0;  // "Undefined" will set up a layer 3 firewall rule and does not filter on layer 4 protocol details.
	ICMP = 1;
	TCP = 6;
	UDP = 17;
	ICMPV6 = 58;
	SCTP = 132;
}

enum TrafficDirection {
	INGRESS = 0;
	EGRESS = 1;
}

enum FirewallAction {
	DROP = 0;
	ACCEPT = 1;
}

enum VniType {
	VNI_IPV4 = 0;
	VNI_IPV6 = 1;
	VNI_BOTH = 2;
}


//// STRUCTURES
message Empty {
}

message Status {
	int32 code = 1;
	string message = 2;
}

message IPAddress {
	IPVersion ipver = 1;
	bytes address = 2;    // holds 4 bytes (IPVersion::IPV4) or 16 bytes (IPVersion::IPV6)
}

message Prefix {
	IPVersion ipver = 1;
	bytes address = 2;        // can hold 4 bytes (IPv4) or 16 bytes (IPv6)
	uint32 length = 3;  // max length is 32 for IPv4 and 128 for IPv6
	bytes underlay_route = 4;
}

message Interface {
	bytes id = 1;
	uint32 vni = 2;
	bytes primary_ipv4 = 3;
	bytes primary_ipv6 = 4;
	bytes underlay_route = 6;
	string pci_name = 7;
}

message IPConfig {
	bytes primary_address = 2;
}

message PXEConfig {
	string next_server = 1;
	string boot_filename = 2;
}

message VirtualFunction {
	string name = 1;      // Linux VF NIC device name
	uint32 domain = 2;    // PCIe Domain
	uint32 bus = 3;       // PCIe Bus
	uint32 slot = 4;      // PCIe Slot
	uint32 function = 5;  // PCIe Function
}

message LBPort {
	uint32 port = 1;
	Protocol protocol = 2;
}

message NATEntry {
	// TODO rework
	IPVersion ipver = 1;
	bytes address = 2;	// Can be both ipv4 and ipv6
	uint32 min_port = 3;
	uint32 max_port = 4;
	bytes underlay_route = 5;
	uint32 vni = 6;
}

message Route {
	IPVersion ipver = 1;
	Prefix prefix = 2;
	uint32 nexthop_vni = 3;
	bytes nexthop_address = 4;
	uint32 weight = 5;
}

message ICMPFilter {
	int32 icmp_type = 1; // -1 matches all ICMP Codes
	int32 icmp_code = 2; // -1 matches all ICMP Types
}

message TCPFilter {
	int32 src_port_lower = 1; // -1 matches all source ports
	int32 src_port_upper = 2;
	int32 dst_port_lower = 3; // -1 matches all destination ports
	int32 dst_port_upper = 4;
}

message UDPFilter {
	int32 src_port_lower = 1; // -1 matches all source ports
	int32 src_port_upper = 2;
	int32 dst_port_lower = 3; // -1 matches all destination ports
	int32 dst_port_upper = 4;
}

message ProtocolFilter {
	oneof filter {
		ICMPFilter icmp = 1;
		TCPFilter tcp = 2;
		UDPFilter udp = 3;
	}
}

// Firewall Rules can be inserted and removed while the interface is running. Linked list is used despite O(n) nature, as the list
// needs to be traversed only once for each packet. (Stateful Firewall and each pass after that is O(1))
// Firewall rules have a priority. "0" being the highest and "65536" being the lowest. Default is "1000".
// Current implementation supports only "allow" rules. The priority doesnt have any influence when we have only "allow" rules.
// Without any installed rule, egress default is "allow" everything and ingress default is "deny" everything. With first installed
// egress rule, egress default changes to "deny" everything except the installed rule(s).
// When a packet matches a firewall rule, the defined action is taken. No further firewall rules will be evaluated thereafter.
message FirewallRule {
	bytes id = 1;
	TrafficDirection direction = 2;
	FirewallAction action = 3;			// Can be only "accept" at the moment.
	uint32 priority = 4;				// For future use. No effect at the moment.
	IPVersion ipver = 5;
	Prefix source_prefix = 6;			// 0.0.0.0 with prefix length 0 matches all source ips
	Prefix destination_prefix = 7;		// 0.0.0.0 with prefix length 0 matches all destination ips
	ProtocolFilter protocol_filter = 8;	// Not defining a protocol filter matches all protocols
}


/// REQUESTS/RESPONSES
message CheckInitializedRequest {
}

message CheckInitializedResponse {
	Status status = 1;
	string uuid = 2;
}

message InitializeRequest {
}

message InitializeResponse {
	Status status = 1;
}

message GetVersionRequest {
	string client_protocol = 1;
	string client_name = 2;
	string client_version = 3;
}

message GetVersionResponse {
	Status status = 1;
	string service_protocol = 2;
	string service_version = 3;
}

message ListInterfacesRequest {
}

message ListInterfacesResponse {
	Status status = 1;
	repeated Interface interfaces = 2;
}

message GetInterfaceRequest {
	bytes interface_id = 1;
}

message GetInterfaceResponse {
	Status status = 1;
	Interface interface = 2;
}

message CreateInterfaceRequest {
	// Define whether a Bare Metal Interface or a Virtual Interface is created.
	// Both instance types cannot be mixed during a session.
	// Maximum number of instantiated bare metal interfaces is 1.
	// Maximum number of Virtual Interfaces is not defined.
	InterfaceType interface_type = 1;
	bytes interface_id = 2;
	uint32 vni = 3;
	IPConfig ipv4_config = 4;
	IPConfig ipv6_config = 5;
	PXEConfig pxe_config = 6;
	// Device with this name will be assigned if it exists, otherwise error is returned.
	string device_name = 7;
}

message CreateInterfaceResponse {
	Status status = 1;
	bytes underlay_route = 2;
	VirtualFunction vf = 3; // Holds VF information when a VM has been created.
}

message DeleteInterfaceRequest {
	bytes interface_id = 1;
}

message DeleteInterfaceResponse {
	Status status = 1;
}

message ListPrefixesRequest {
	bytes interface_id = 1;
}

message ListPrefixesResponse {
	Status status = 1;
	repeated Prefix prefixes = 2;
}

message CreatePrefixRequest {
	bytes interface_id = 1;
	Prefix prefix = 2;
}

message CreatePrefixResponse {
	Status status = 1;
	bytes underlay_route = 2;
}

message DeletePrefixRequest {
	bytes interface_id = 1;
	Prefix prefix = 2;
}

message DeletePrefixResponse {
	Status status = 1;
}

message ListLoadBalancerPrefixesRequest {
	bytes interface_id = 1;
}

message ListLoadBalancerPrefixesResponse {
	Status status = 1;
	repeated Prefix prefixes = 2;
}

message CreateLoadBalancerPrefixRequest {
	bytes interface_id = 1;
	Prefix prefix = 2;
}

message CreateLoadBalancerPrefixResponse {
	Status status = 1;
	bytes underlay_route = 2;
}

message DeleteLoadBalancerPrefixRequest {
	bytes interface_id = 1;
	Prefix prefix = 2;
}

message DeleteLoadBalancerPrefixResponse {
	Status status = 1;
}

message CreateVIPRequest {
	bytes interface_id = 1;
	IPAddress vip_ip = 2;
}

message CreateVIPResponse {
	Status status = 1;
	bytes underlay_route = 2;
}

message GetVIPRequest {
	bytes interface_id = 1;
}

message GetVIPResponse {
	Status status = 1;
	IPAddress vip_ip = 2;
	bytes underlay_route = 3;
}

message DeleteVIPRequest {
	bytes interface_id = 1;
}

message DeleteVIPResponse {
	Status status = 1;
}

message CreateLoadBalancerRequest {
	bytes loadbalancer_id = 1;
	IPAddress loadbalanced_ip = 2;
	uint32 vni = 3;
	repeated LBPort loadbalanced_ports = 4;
}

message CreateLoadBalancerResponse {
	Status status = 1;
	bytes underlay_route = 2;
}

message GetLoadBalancerRequest {
	bytes loadbalancer_id = 1;
}

message GetLoadBalancerResponse {
	Status status = 1;
	IPAddress loadbalanced_ip = 2;
	uint32 vni = 3;
	repeated LBPort loadbalanced_ports = 4;
	bytes underlay_route = 5;
}

message DeleteLoadBalancerRequest {
	bytes loadbalancer_id = 1;
}

message DeleteLoadBalancerResponse {
	Status status = 1;
}

message CreateLoadBalancerTargetRequest {
	bytes loadbalancer_id = 1;
	IPAddress target_ip = 2;
}

message CreateLoadBalancerTargetResponse {
	Status status = 1;
}

message ListLoadBalancerTargetsRequest {
	bytes loadbalancer_id = 1;
}

message ListLoadBalancerTargetsResponse {
	Status status = 1;
	repeated IPAddress target_ips = 2;
}

message DeleteLoadBalancerTargetRequest {
	bytes loadbalancer_id = 1;
	IPAddress target_ip = 2;
}

message DeleteLoadBalancerTargetResponse {
	Status status = 1;
}

message CreateNATRequest {
	bytes interface_id =1;
	IPAddress nat_ip = 2;
	uint32 min_port = 3; // port should be uint16 (less than 65536)
	uint32 max_port = 4;
}

message CreateNATResponse {
	Status status = 1;
	bytes underlay_route = 2;
}

message GetNATRequest {
	bytes interface_id =1;
}

message GetNATResponse {
	Status status = 1;
	IPAddress nat_ip = 2;
	uint32 min_port = 3; // port should be uint16 (less than 65536)
	uint32 max_port = 4;
	bytes underlay_route = 5;
}

message DeleteNATRequest {
	bytes interface_id = 1;
}

message DeleteNATResponse {
	Status status = 1;
}

message CreateNeighborNATRequest {
	IPAddress nat_ip = 1;
	uint32 vni = 2;
	uint32 min_port = 3; // port should be uint16 (less than 65536)
	uint32 max_port = 4;
	bytes underlay_route = 5;
}

message CreateNeighborNATResponse {
	Status status = 1;
}

message DeleteNeighborNATRequest {
	IPAddress nat_ip = 1;
	uint32 vni = 2;
	uint32 min_port = 3; // port should be uint16 (less than 65536)
	uint32 max_port = 4;
}

message DeleteNeighborNATResponse {
	Status status = 1;
}

message ListLocalNATsRequest {
	IPAddress nat_ip = 1;
}

message ListLocalNATsResponse {
	Status status = 1;
	repeated NATEntry nat_entries = 2;
}

message ListNeighborNATsRequest {
	IPAddress nat_ip = 1;
}

message ListNeighborNATsResponse {
	Status status = 1;
	repeated NATEntry nat_entries = 2;
}

message ListRoutesRequest {
	uint32 vni = 1;
}

message ListRoutesResponse {
	Status status = 1;
	repeated Route routes = 2;
}

message CreateRouteRequest {
	uint32 vni = 1;
	Route route = 2;
}

message CreateRouteResponse {
	Status status = 1;
}

message DeleteRouteRequest {
	uint32 vni = 1;
	Route route = 2;
}

message DeleteRouteResponse {
	Status status = 1;
}

message CheckVniInUseRequest {
	uint32 vni = 1;
	VniType type = 2;
}

message CheckVniInUseResponse {
	Status status = 1;
	bool inUse = 2;
}

message ResetVniRequest {
	uint32 vni = 1;
	VniType type = 2;
}
message ResetVniResponse {
	Status status = 1;
}

message ListFirewallRulesRequest {
	bytes interface_id = 1;
}

message ListFirewallRulesResponse {
	Status status = 1;
	repeated FirewallRule rules = 2;
}

message CreateFirewallRuleRequest {
	bytes interface_id = 1;
	FirewallRule rule = 2;
}

message CreateFirewallRuleResponse {
	Status status = 1;
	bytes rule_id = 2;
}

message GetFirewallRuleRequest {
	bytes interface_id = 1;
	bytes rule_id = 2;
}

message GetFirewallRuleResponse {
	Status status = 1;
	FirewallRule rule = 2;
}

message DeleteFirewallRuleRequest {
	bytes interface_id = 1;
	bytes rule_id = 2;
}

message DeleteFirewallRuleResponse {
	Status status = 1;
}


service DPDKonmetal {
	//// INITIALIZATION
	// initialized indicates if the DPDK app has been initialized already, if so an UUID is returned.
	// this UUID gets changed in case the dp-service gets restarted.
	rpc CheckInitialized(CheckInitializedRequest) returns (CheckInitializedResponse) {}

	// init will be called once for initial set up of the DPDK app.
	// init returns an error if the DPDK app has been initialized already. So check if it got initialized before calling init.
	rpc Initialize(InitializeRequest) returns (InitializeResponse) {}

	//// VERSIONING
	// Exchange protocol/app versions to establish communication
	rpc GetVersion(GetVersionRequest) returns (GetVersionResponse) {}

	//// INTERFACES
	rpc ListInterfaces(ListInterfacesRequest) returns (ListInterfacesResponse) {}
	rpc GetInterface(GetInterfaceRequest) returns (GetInterfaceResponse) {}

	// CreateInterface creates and configures a VF (hypervisor case) or PF (bare metal) for the new interface.
	// If the interface's VNet is not known to the DPDK app yet, the VNet and its routing table will be intialized.
	// After calling CreateInterface() the Client has to make sure that the routing table of the corresponding VNet is filled (use ListRoutes and AddRoute as required).
	rpc CreateInterface(CreateInterfaceRequest) returns (CreateInterfaceResponse) {}

	// DeleteInterface removes all networking configuration of a interface from the DPDK app.
	// The VF will be released and can be reused for other VMs.
	// If the interface was the last interface of a VNet on this hypervisor, the VNet and its routes will be freed from the DPDK app.
	rpc DeleteInterface(DeleteInterfaceRequest) returns (DeleteInterfaceResponse) {}

	// ListPrefixes returns a list of prefixes, that will be routed to the interface by the DPDK app.
	// For example this could be a node's Kubernetes Pod CIDR.
	rpc ListPrefixes(ListPrefixesRequest) returns (ListPrefixesResponse) {}
	rpc CreatePrefix(CreatePrefixRequest) returns (CreatePrefixResponse) {}
	rpc DeletePrefix(DeletePrefixRequest) returns (DeletePrefixResponse) {}

	// LoadBalancerTargetPrefix(es) are similar to Prefixes but used for LoadBalancing purposes
	rpc ListLoadBalancerPrefixes(ListLoadBalancerPrefixesRequest) returns (ListLoadBalancerPrefixesResponse) {}
	rpc CreateLoadBalancerPrefix(CreateLoadBalancerPrefixRequest) returns (CreateLoadBalancerPrefixResponse) {}
	rpc DeleteLoadBalancerPrefix(DeleteLoadBalancerPrefixRequest) returns (DeleteLoadBalancerPrefixResponse) {}

	// NAT related, add/get/del Virtual IP for a given Interface
	rpc CreateVIP(CreateVIPRequest) returns (CreateVIPResponse) {}
	rpc GetVIP(GetVIPRequest) returns (GetVIPResponse) {}
	rpc DeleteVIP(DeleteVIPRequest) returns (DeleteVIPResponse) {}

	// create/list/del Loadbalancer for a given IP to be loadbalanced
	rpc CreateLoadBalancer(CreateLoadBalancerRequest) returns (CreateLoadBalancerResponse) {}
	rpc GetLoadBalancer(GetLoadBalancerRequest) returns (GetLoadBalancerResponse) {}
	rpc DeleteLoadBalancer(DeleteLoadBalancerRequest) returns (DeleteLoadBalancerResponse) {}

	// create/list/del Loadbalancer Targets for a given Loadbalancer ID
	rpc CreateLoadBalancerTarget(CreateLoadBalancerTargetRequest) returns (CreateLoadBalancerTargetResponse) {}
	rpc ListLoadBalancerTargets(ListLoadBalancerTargetsRequest) returns (ListLoadBalancerTargetsResponse) {}
	rpc DeleteLoadBalancerTarget(DeleteLoadBalancerTargetRequest) returns (DeleteLoadBalancerTargetResponse) {}

	// Network-NAT related, add/del/get a NAT for an interface
	rpc CreateNAT(CreateNATRequest) returns (CreateNATResponse) {}
	rpc GetNAT(GetNATRequest) returns (GetNATResponse) {}
	rpc DeleteNAT(DeleteNATRequest) returns (DeleteNATResponse) {}

	rpc ListLocalNATs(ListLocalNATsRequest) returns (ListLocalNATsResponse) {}

	rpc CreateNeighborNAT(CreateNeighborNATRequest) returns (CreateNeighborNATResponse) {}
	rpc DeleteNeighborNAT(DeleteNeighborNATRequest) returns (DeleteNeighborNATResponse) {}
	rpc ListNeighborNATs(ListNeighborNATsRequest) returns (ListNeighborNATsResponse) {}

	//// ROUTES
	rpc ListRoutes(ListRoutesRequest) returns (ListRoutesResponse) {}

	// CreateRoute adds a new route to a VNet's routing table (identified by VNI).
	// If the DPDK application does not hold any interface in the specified VNet, an error will be returned.
	rpc CreateRoute(CreateRouteRequest) returns (CreateRouteResponse) {}

	// DeleteRoute removes a route from a VNet.
	// If the route does not exist, an error will be returned.
	rpc DeleteRoute(DeleteRouteRequest) returns (DeleteRouteResponse) {}

	// VNI internal state information
	// VNI can be in use by interfaces and by loadbalancer. So get information
	// whether the VNI in question is in use or not.
	rpc CheckVniInUse(CheckVniInUseRequest) returns (CheckVniInUseResponse) {}
	rpc ResetVni(ResetVniRequest) returns (ResetVniResponse) {}

	//// FIREWALL
	rpc ListFirewallRules(ListFirewallRulesRequest) returns (ListFirewallRulesResponse) {}
	rpc CreateFirewallRule(CreateFirewallRuleRequest) returns (CreateFirewallRuleResponse) {}
	rpc GetFirewallRule(GetFirewallRuleRequest) returns (GetFirewallRuleResponse) {}
	rpc DeleteFirewallRule(DeleteFirewallRuleRequest) returns (DeleteFirewallRuleResponse) {}
}
