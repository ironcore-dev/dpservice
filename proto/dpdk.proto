syntax = "proto3";

package dpdkonmetal;
option go_package = "./dpdkproto";

enum InterfaceType {
	VirtualInterface = 0;
	BareMetalInterface = 1;
}

enum IPVersion {
	IPv4 = 0;
	IPv6 = 1;
}

enum Protocol {
	Undefined = 0;  // "Undefined" will set up a layer 3 firewall rule and does not filter on layer 4 protocol details.
	ICMP = 1;
	TCP = 6;
	UDP = 17;
	ICMPv6 = 58;
	SCTP = 132;
}

enum TrafficDirection {
	Ingress = 0;
	Egress = 1;
}

enum FirewallAction {
	Drop = 0;
	Accept = 1;
}

enum NATInfoType {
	NATInfoTypeZero = 0;
	NATInfoLocal = 1;
	NATInfoNeigh = 2;
}

enum VniType {
	VniIpv4 = 0;
	VniIpv6 = 1;
	VniIpv4AndIpv6 = 2;
}

message Status {
	int32 error = 1;
	string message = 2;
}

message CreateInterfaceLoadBalancerPrefixResponse {
	Status status = 1;
	bytes underlayRoute = 2;
}

message IpAdditionResponse {
	Status status = 1;
	bytes underlayRoute = 2;
}

message AddNATResponse {
	Status status = 1;
	bytes underlayRoute = 2;
}

message GetNATResponse {
	Status status = 1;
	NATIP natVIPIP = 2;
	uint32 minPort = 3; // port should be uint16 (less than 65536)
	uint32 maxPort = 4;
	bytes underlayRoute = 5;
}

message CreateLoadBalancerResponse {
	Status status = 1;
	bytes underlayRoute = 2;
}

message Empty {}

message Prefix {
	IPVersion ipVersion = 1;
	bytes address = 2;        // can hold 4 bytes (IPv4) or 16 bytes (IPv6)
	uint32 prefixLength = 3;  // max length is 32 for IPv4 and 128 for IPv6
	bytes underlayRoute = 4;
}

message LBPrefix {
	IPVersion ipVersion = 1;
	bytes address = 2;        // can hold 4 bytes (IPv4) or 16 bytes (IPv6)
	uint32 prefixLength = 3;  // max length is 32 for IPv4 and 128 for IPv6
	bytes underlayRoute = 4;
}

message InitConfig {
	Prefix underlayIPv6Prefix = 1;   // prefix in the underlay network that is routed to the DPDK app
	repeated string uplinkPorts = 2; // Linux name of the NICs that are connected to the Leaf Switches
	repeated string pfNames = 3;     // Linux name of the Physical Functions, that Virtual Functions will be derived from
}

message PXEConfig {
	string nextServer = 1;
	string bootFileName = 2;
}

message ProtocolFilter {
	oneof filter {
		ICMPFilter icmp = 1;
		TCPFilter tcp = 2;
		UDPFilter udp = 3;
	}
}

message ICMPFilter {
	int32 icmpType = 1; // -1 matches all ICMP Codes
	int32 icmpCode = 2; // -1 matches all ICMP Types
}

message TCPFilter {
	int32 srcPortLower = 1; // -1 matches all source ports
	int32 srcPortUpper = 2;
	int32 dstPortLower = 3; // -1 matches all destination ports
	int32 dstPortUpper = 4;
}

message UDPFilter {
	int32 srcPortLower = 1; // -1 matches all source ports
	int32 srcPortUpper = 2;
	int32 dstPortLower = 3; // -1 matches all destination ports
	int32 dstPortUpper = 4;
}

// Firewall Rules can be inserted and removed while the interface is running. Linked list is used despite O(n) nature, as the list
// needs to be traversed only once for each packet. (Stateful Firewall and each pass after that is O(1))
// Firewall rules have a priority. "0" being the highest and "65536" being the lowest. Default is "1000".
// Current implementation supports only "allow" rules. The priority doesnt have any influence when we have only "allow" rules.
// Without any installed rule, egress default is "allow" everything and ingress default is "deny" everything. With first installed
// egress rule, egress default changes to "deny" everything except the installed rule(s).
// When a packet matches a firewall rule, the defined action is taken. No further firewall rules will be evaluated thereafter.
message FirewallRule {
	bytes ruleID = 1;
	TrafficDirection direction = 2;
	FirewallAction action = 3; // Can be only "accept" at the moment.
	uint32 priority = 4; // For future use. No effect at the moment.

	IPVersion ipVersion = 5;
	Prefix sourcePrefix = 6; // 0.0.0.0 with prefix length 0 matches all source ips
	Prefix destinationPrefix = 7; // 0.0.0.0 with prefix length 0 matches all destination ips

	ProtocolFilter protocolFilter = 8; // Not defining a protocol filter matches all protocols
}

message IPConfig {
	IPVersion ipVersion = 1;

	// DHCP Options
	bytes primaryAddress = 2;
	uint32 mtu = 3;
	string dhcpHostname = 4;
	string dhcpDomainname = 5;
	PXEConfig pxeConfig = 6;
	repeated string ntp = 7;
	repeated bytes dns = 8;

	repeated FirewallRule firewallRules = 9;
	repeated Prefix interfacePrefixes = 10;
}

message ThrottlingConfig {
	uint32 ingressPacketsPerSecond = 1;
	uint32 ingressMegabitsPerSecond = 2;

	uint32 egressPacketsPerSecond = 3;
	uint32 egressMegabitsPerSecond = 4;

	uint32 maxOpenFlows = 5;
}

message CreateInterfaceRequest {
	// interfaceType defines whether a Bare Metal Interface or a Virtual Interface is created.
	// Both instance types cannot be mixed during a session.
	// Maximum number of instantiated bare metal interfaces is 1.
	// Maximum number of Virtual Interfaces is not defined.
	// If you specify device name, a device with this name will be assigned, if it exists
	// otherwise an error code. If you dont specify any device name, next available VF 
	// will be assigned. 
	InterfaceType interfaceType = 1;

	bytes interfaceID = 2;
	uint32 vni = 3;
	IPConfig ipv4Config = 4;
	IPConfig ipv6Config = 5;
	string deviceName = 6;
	ThrottlingConfig throttlingConfig = 7;
}

message Interface {
	bytes interfaceID = 1;
	uint32 vni = 2;
	bytes primaryIPv4Address = 3;
	bytes primaryIPv6Address = 4;
	ThrottlingConfig throttlingConfig = 5;
	bytes underlayRoute = 6;
	string pciDpName = 7;
}

message InterfaceIDMsg {
	bytes interfaceID = 1;
}

message GetInterfaceResponse {
	Status status = 1;
	Interface interface = 2;
}

message ListInterfaceLoadBalancerPrefixesRequest {
	bytes interfaceID = 1;
}

message ListInterfaceLoadBalancerPrefixesResponse {
	repeated LBPrefix prefixes = 1;
}

message InterfaceVIPIP {
	Status status = 1;
	IPVersion ipVersion = 2;
	bytes address = 3;	// Can be both ipv4 and ipv6
	bytes underlayRoute = 4;
}

message LBIP {
	IPVersion ipVersion = 1;
	bytes address = 2;	// Can be both ipv4 and ipv6
}

message NATIP {
	IPVersion ipVersion = 1;
	bytes address = 2;	// Can be both ipv4 and ipv6
}

message InterfaceVIPMsg {
	bytes interfaceID = 1;
	InterfaceVIPIP interfaceVIPIP = 2;
}

message GetLoadBalancerRequest {
	bytes loadBalancerID = 1;
}

message GetLoadBalancerTargetsRequest {
	bytes loadBalancerID = 1;
}

message DeleteLoadBalancerRequest {
	bytes loadBalancerID = 1;
}

message LBPort {
	uint32 port = 1;
	Protocol protocol = 2;
}

message GetLoadBalancerTargetsResponse {
	Status status = 1;
	repeated LBIP targetIPs = 2;
}

message GetLoadBalancerResponse {
	Status status = 1;
	LBIP lbVipIP = 2;
	uint32 vni = 3;
	repeated LBPort lbports = 4;
	bytes underlayRoute = 5;
}

message CreateLoadBalancerRequest {
	bytes loadBalancerID = 1;
	LBIP lbVipIP = 2;
	uint32 vni = 3;
	repeated LBPort lbports = 4;
}

message AddLoadBalancerTargetRequest {
	bytes loadBalancerID = 1;
	LBIP targetIP = 2;
}

message DeleteLoadBalancerTargetRequest {
	bytes loadBalancerID = 1;
	LBIP targetIP = 2;
}

message InterfacesMsg {
	repeated Interface interfaces = 1;
}

message AddNATRequest {
	bytes interfaceID =1;
	NATIP natVIPIP = 2;
	uint32 minPort = 3; // port should be uint16 (less than 65536)
	uint32 maxPort = 4;
}

message GetNATRequest {
	bytes interfaceID =1;
}

message GetNATInfoRequest {
	NATIP natVIPIP = 1; // list all local machines that are behind this IP
	NATInfoType natInfoType = 2; 
}

message NATInfoEntry {
	IPVersion ipVersion = 1;
	bytes address = 2;	// Can be both ipv4 and ipv6
	uint32 minPort = 3; 
	uint32 maxPort = 4;
	bytes underlayRoute = 5;
	uint32 vni = 6;
}

message GetNATInfoResponse {
	NATIP natVIPIP = 1;
	NATInfoType natInfoType = 2; 
	repeated NATInfoEntry natInfoEntries = 3;
} 

message DeleteNATRequest {
	bytes interfaceID =1;
}

message AddNeighborNATRequest {
	NATIP natVIPIP = 1;
	uint32 vni = 2;
	uint32 minPort = 3; // port should be uint16 (less than 65536)
	uint32 maxPort = 4;
	bytes underlayRoute = 5;
}

message DeleteNeighborNATRequest {
	NATIP natVIPIP = 1;
	uint32 vni = 2;
	uint32 minPort = 3; // port should be uint16 (less than 65536)
	uint32 maxPort = 4;
}

message RuleIDMsg {
	bytes ruleID = 1;
}

message ThrottlingConfigMsg {
	InterfaceIDMsg interfaceID = 1;
	ThrottlingConfig throttlingConfig = 2;
}

message CreateInterfaceLoadBalancerPrefixRequest {
	InterfaceIDMsg interfaceID = 1;
	Prefix prefix = 2;
}

message DeleteInterfaceLoadBalancerPrefixRequest {
	InterfaceIDMsg interfaceID = 1;
	Prefix prefix = 2;
}

message InterfacePrefixMsg {
	InterfaceIDMsg interfaceID = 1;
	Prefix prefix = 2;
}

message PrefixesMsg {
	repeated Prefix prefixes = 1;
}

message VNIMsg {
	uint32 vni = 1;
}

message VNIRouteMsg {
	VNIMsg vni = 1;
	Route route = 2;
}

message RoutesMsg {
	repeated Route routes = 1;
}

message ListFirewallRulesRequest {
	bytes interfaceID = 1;
}

message ListFirewallRulesResponse {
	repeated FirewallRule rules = 1;
}

message GetFirewallRuleRequest {
	bytes interfaceID = 1;
	bytes ruleID = 2;
}

message GetFirewallRuleResponse {
	Status status = 1;
	FirewallRule rule = 2;
}

message DeleteFirewallRuleRequest {
	bytes interfaceID = 1;
	bytes ruleID = 2;
}

message AddFirewallRuleRequest {
	bytes interfaceID = 1;
	FirewallRule rule = 2;
}

message AddFirewallRuleResponse {
	Status status = 1;
	bytes ruleID = 2;
}

message UUIDMsg {
	string uuid = 1;
}

message VirtualFunction {
	string name = 1;      // Linux VF NIC device name
	uint32 domain = 2;    // PCIe Domain
	uint32 bus = 3;       // PCIe Bus
	uint32 slot = 4;      // PCIe Slot
	uint32 function = 5;  // PCIe Function
}

message CreateInterfaceResponse {
	IpAdditionResponse response = 1;
	VirtualFunction vf = 2; // Holds VF information when a VM has been created.
}

message Route {
	IPVersion ipVersion = 1;
	Prefix prefix = 2;
	uint32 nexthopVNI = 3;
	bytes nexthopAddress = 4;
	uint32 weight = 5;
}

message IsVniInUseRequest {
	uint32 vni = 1;
	VniType type = 2;
}

message IsVniInUseResponse {
	bool inUse = 1;
	Status status = 2;
}

message ResetVniRequest {
	uint32 vni = 1;
	VniType type = 2;
}

message GetVersionRequest {
	string clientProto = 1;
	string clientName = 2;
	string clientVer = 3;
}

message GetVersionResponse {
	Status status = 1;
	string svcProto = 2;
	string svcVer = 3;
}

service DPDKonmetal {
	//// INITIALIZATION
	// initialized indicates if the DPDK app has been initialized already, if so an UUID is returned.
	// this UUID gets changed in case the dp-service gets restarted.
	rpc initialized(Empty) returns (UUIDMsg) {}

	// init will be called once for initial set up of the DPDK app.
	// init returns an error if the DPDK app has been initialized already. So check if it got initialized before calling init.
	rpc init(InitConfig) returns (Status) {}

	//// VERSIONING
	// Exchange protocol/app versions to establish communication
	rpc getVersion(GetVersionRequest) returns (GetVersionResponse) {}

	//// INTERFACES
	rpc listInterfaces(Empty) returns (InterfacesMsg) {}

	rpc getInterface(InterfaceIDMsg) returns (GetInterfaceResponse) {}

	// createInterface creates and configures a VF (hypervisor case) or PF (bare metal) for the new interface.
	// If the interface's VNet is not known to the DPDK app yet, the VNet and its routing table will be intialized.
	// After calling createInterface() the Client has to make sure that the routing table of the corresponding VNet is filled (use listRoutes and addRoute as required).
	rpc createInterface(CreateInterfaceRequest) returns (CreateInterfaceResponse) {}

	// deleteInterface removes all networking configuration of a interface from the DPDK app.
	// The VF will be released and can be reused for other VMs.
	// If the interface was the last interface of a VNet on this hypervisor, the VNet and its routes will be freed from the DPDK app.
	rpc deleteInterface(InterfaceIDMsg) returns (Status) {}

	// updateThrottlingConfig changes a interface's throttling configuration during runtime.
	rpc updateThrottlingConfig(ThrottlingConfigMsg) returns (Status) {}

	// listInterfacePrefixes returns a list of prefixes, that will be routed to the interface by the DPDK app.
	// For example this could be a node's Kubernetes Pod CIDR.
	rpc listInterfacePrefixes(InterfaceIDMsg) returns (PrefixesMsg) {}
	rpc addInterfacePrefix(InterfacePrefixMsg) returns (IpAdditionResponse) {}
	rpc deleteInterfacePrefix(InterfacePrefixMsg) returns (Status) {}

	// LoadBalancerTargetPrefix(es) are similar to Prefixes but used for LoadBalancing purposes
	rpc listInterfaceLoadBalancerPrefixes(ListInterfaceLoadBalancerPrefixesRequest) returns (ListInterfaceLoadBalancerPrefixesResponse) {}
	rpc createInterfaceLoadBalancerPrefix(CreateInterfaceLoadBalancerPrefixRequest) returns (CreateInterfaceLoadBalancerPrefixResponse) {}
	rpc deleteInterfaceLoadBalancerPrefix(DeleteInterfaceLoadBalancerPrefixRequest) returns (Status) {}

	// NAT related, add/get/del Virtual IP for a given Interface
	rpc addInterfaceVIP(InterfaceVIPMsg) returns (IpAdditionResponse) {}
	rpc getInterfaceVIP(InterfaceIDMsg) returns (InterfaceVIPIP) {}
	rpc deleteInterfaceVIP(InterfaceIDMsg) returns (Status) {}

	// create/list/del Loadbalancer for a given IP to be loadbalanced
	rpc createLoadBalancer(CreateLoadBalancerRequest) returns (CreateLoadBalancerResponse) {}
	rpc getLoadBalancer(GetLoadBalancerRequest) returns (GetLoadBalancerResponse) {}
	rpc deleteLoadBalancer(DeleteLoadBalancerRequest) returns (Status) {}

	// create/list/del Loadbalancer Targets for a given Loadbalancer ID
	rpc addLoadBalancerTarget(AddLoadBalancerTargetRequest) returns (Status) {}
	rpc getLoadBalancerTargets(GetLoadBalancerTargetsRequest) returns (GetLoadBalancerTargetsResponse) {}
	rpc deleteLoadBalancerTarget(DeleteLoadBalancerTargetRequest) returns (Status) {}

	// Network-NAT related, add/del/get a NAT for an interface
	rpc addNAT(AddNATRequest) returns (AddNATResponse) {}
	rpc getNAT(GetNATRequest) returns (GetNATResponse) {}
	rpc deleteNAT(DeleteNATRequest) returns (Status) {}

	rpc addNeighborNAT(AddNeighborNATRequest) returns (Status) {}
	rpc deleteNeighborNAT(DeleteNeighborNATRequest) returns (Status) {}
	
	rpc getNATInfo(GetNATInfoRequest) returns (GetNATInfoResponse) {}

	//// ROUTES
	rpc listRoutes(VNIMsg) returns (RoutesMsg) {}

	// addRoutes adds a new route to a VNet's routing table (identified by VNI).
	// If the DPDK application does not hold any interface in the specified VNet, an error will be returned.
	rpc addRoute(VNIRouteMsg) returns (Status) {}

	// deleteRoute removes a route from a VNet.
	// If the route does not exist, an error will be returned.
	rpc deleteRoute(VNIRouteMsg) returns (Status) {}

	// VNI internal state information
	// VNI can be in use by interfaces and by loadbalancer. So get information
	// whether the VNI in question is in use or not.
	rpc isVniInUse(IsVniInUseRequest) returns (IsVniInUseResponse) {}
	rpc resetVni(ResetVniRequest) returns (Status) {}

	//// FIREWALL
	rpc listFirewallRules(ListFirewallRulesRequest) returns (ListFirewallRulesResponse) {}
	rpc addFirewallRule(AddFirewallRuleRequest) returns (AddFirewallRuleResponse) {}
	rpc getFirewallRule(GetFirewallRuleRequest) returns (GetFirewallRuleResponse) {}
	rpc deleteFirewallRule(DeleteFirewallRuleRequest) returns (Status) {}
}
